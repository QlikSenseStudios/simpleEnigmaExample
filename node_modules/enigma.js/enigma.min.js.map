{"version":3,"file":"enigma.min.js","sources":["node_modules/node-event-emitter/index.js","src/event-emitter.js","src/error.js","src/error-codes.js","src/session.js","src/key-value-cache.js","src/schema.js","src/rpc-resolver.js","src/rpc.js","src/suspend-resume.js","src/interceptors/delta-request-interceptor.js","src/interceptors/api-response-interceptor.js","node_modules/extend/index.js","src/json-patch.js","src/interceptors/delta-response-interceptor.js","src/interceptors/error-response-interceptor.js","src/interceptors/out-param-response-interceptor.js","src/interceptors/result-response-interceptor.js","src/intercept.js","src/api-cache.js","src/enigma.js"],"sourcesContent":["/**\n * Utility functions\n */\n\nvar util = {};\n\nutil.isObject = function isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nutil.isNumber = function isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nutil.isUndefined = function isUndefined(arg) {\n  return arg === void 0;\n}\n\nutil.isFunction = function isFunction(arg){\n  return typeof arg === 'function';\n}\n\n\n/**\n * EventEmitter class\n */\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\nEventEmitter.init = function() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!util.isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error' && !this._events.error) {\n    er = arguments[1];\n    if (er instanceof Error) {\n      throw er; // Unhandled 'error' event\n    } else {\n      throw Error('Uncaught, unspecified \"error\" event.');\n    }\n    return false;\n  }\n\n  handler = this._events[type];\n\n  if (util.isUndefined(handler))\n    return false;\n\n  if (util.isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        len = arguments.length;\n        args = new Array(len - 1);\n        for (i = 1; i < len; i++)\n          args[i - 1] = arguments[i];\n        handler.apply(this, args);\n    }\n  } else if (util.isObject(handler)) {\n    len = arguments.length;\n    args = new Array(len - 1);\n    for (i = 1; i < len; i++)\n      args[i - 1] = arguments[i];\n\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!util.isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              util.isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (util.isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (util.isObject(this._events[type]) && !this._events[type].warned) {\n    var m;\n    if (!util.isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n\n      if (util.isFunction(console.error)) {\n        console.error('(node) warning: possible EventEmitter memory ' +\n                      'leak detected. %d listeners added. ' +\n                      'Use emitter.setMaxListeners() to increase limit.',\n                      this._events[type].length);\n      }\n      if (util.isFunction(console.trace))\n        console.trace();\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!util.isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!util.isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (util.isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (util.isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (util.isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (Array.isArray(listeners)) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (util.isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  var ret;\n  if (!emitter._events || !emitter._events[type])\n    ret = 0;\n  else if (util.isFunction(emitter._events[type]))\n    ret = 1;\n  else\n    ret = emitter._events[type].length;\n  return ret;\n};\n","import EventEmitter from 'node-event-emitter';\n\n/**\n* @module EventEmitter\n* @private\n*/\nexport default {\n\n  /**\n  * Function used to add event handling to objects passed in.\n  * @param {Object} obj Object instance that will get event handling.\n  */\n  mixin: (obj) => {\n    Object.keys(EventEmitter.prototype).forEach((key) => {\n      obj[key] = EventEmitter.prototype[key];\n    });\n    EventEmitter.init(obj);\n  },\n};\n","/**\n * Error containing a custom error code.\n * @extends Error\n * @property {number} code The error code as defined by `errorCodes`.\n * @property {boolean} enigmaError=true\n * @property {Object} [original] the websocket event that is the source of the error.\n */\nclass EnigmaError extends Error {\n  constructor(name, code, original) {\n    super(name);\n    this.code = code;\n    this.enigmaError = true;\n    this.original = original;\n  }\n}\n\n/**\n * Create an enigmaError\n * @private\n * @param {Number} code A proper error code from `errorCodes`\n * @param {String} name A message/name of the enigmaError.\n * @param {Object} [original] the websocket event that is the source of the error.\n * @returns {EnigmaError}\n */\nexport default function createEnigmaError(code, name, original) {\n  return new EnigmaError(name, code, original);\n}\n","/**\n * This is a list of error codes that can be thrown from enigma.js API calls.\n * @entry\n * @see EnigmaError\n * @enum\n * @example <caption>Handling an enigma.js error</caption>\n * const { NOT_CONNECTED } = require('enigma.js/error-codes');\n * try {\n *   const layout = await model.getLayout();\n * } catch (err) {\n *   if (err.code === NOT_CONNECTED) {\n *     console.log('Tried to communicate on a session that is closed');\n *   }\n * }\n */\nconst errorCodes = {\n  /**\n   * You're trying to send data on a socket that's not connected.\n   * @type {number}\n   */\n  NOT_CONNECTED: -1,\n  /**\n   * The object you're trying to fetch does not exist.\n   * @type {number}\n   */\n  OBJECT_NOT_FOUND: -2,\n  /**\n   * Unexpected RPC response, expected array of patches.\n   * @type {number}\n   */\n  EXPECTED_ARRAY_OF_PATCHES: -3,\n  /**\n   * Not an object that can be patched.\n   * @type {number}\n   */\n  PATCH_HAS_NO_PARENT: -4,\n  /**\n   * This entry is already defined with another key.\n   * @type {number}\n   */\n  ENTRY_ALREADY_DEFINED: -5,\n  /**\n   * You need to supply a configuration.\n   * @type {number}\n   */\n  NO_CONFIG_SUPPLIED: -6,\n  /**\n   * There's no promise object available (polyfill required?).\n   * @type {number}\n   */\n  PROMISE_REQUIRED: -7,\n  /**\n   * The schema struct type you requested does not exist.\n   * @type {number}\n   */\n  SCHEMA_STRUCT_TYPE_NOT_FOUND: -8,\n  /**\n   * Can't override this function.\n   * @type {number}\n   */\n  SCHEMA_MIXIN_CANT_OVERRIDE_FUNCTION: -9,\n  /**\n   * Extend is not allowed for this mixin.\n   * @type {number}\n   */\n  SCHEMA_MIXIN_EXTEND_NOT_ALLOWED: -10,\n  /**\n   * Session suspended - no interaction allowed.\n   * @type {number}\n   */\n  SESSION_SUSPENDED: -11,\n  /**\n   * onlyIfAttached supplied, but you got SESSION_CREATED.\n   * @type {number}\n   */\n  SESSION_NOT_ATTACHED: -12,\n};\n\nexport default errorCodes;\n","import EventEmitter from './event-emitter';\n\nimport createEnigmaError from './error';\nimport errorCodes from './error-codes';\n\nconst RPC_CLOSE_NORMAL = 1000;\nconst RPC_CLOSE_MANUAL_SUSPEND = 4000;\n\nlet cacheId = 0;\n\n/**\n * The QIX Engine session object.\n */\nclass Session {\n  /**\n   * Handles all JSON-RPC notification events, 'notification:* or handles a specific JSON-RPC\n   * notification event, 'notification:OnConnected'. These events depend on the product from which\n   * you use QIX Engine.\n   * @event Session#notification\n   * @type {Object}\n   * @example <caption>Bind the notification events</caption>\n   * // bind all notifications to console.log:\n   * session.on('notification:*', console.log);\n   * // bind a specific notification to console.log:\n   * session.on('notification:OnConnected', console.log);\n   */\n\n  /**\n   * Handles websocket messages. Generally used for debugging purposes. `traffic:*` will handle all\n   * websocket messages, `traffic:sent` will handle outgoing messages, and `traffic:received` will\n   * handle incoming messages.\n   * @event Session#traffic\n   * @type {Object}\n   * @example <caption>Bind the traffic events</caption>\n   * // bind both in- and outbound traffic to console.log:\n   * session.on('traffic:*', console.log);\n   * // bind outbound traffic to console.log:\n   * session.on('traffic:sent', console.log);\n   * // bind inbound traffic to console.log:\n   * session.on('traffic:received', console.log);\n   */\n\n  constructor(options) {\n    const session = this;\n    Object.assign(session, options);\n    this.Promise = this.config.Promise;\n    this.definition = this.config.definition;\n    EventEmitter.mixin(session);\n    cacheId += 1;\n    session.id = cacheId;\n    session.rpc.on('socket-error', session.onRpcError.bind(session));\n    session.rpc.on('closed', session.onRpcClosed.bind(session));\n    session.rpc.on('message', session.onRpcMessage.bind(session));\n    session.rpc.on('notification', session.onRpcNotification.bind(session));\n    session.rpc.on('traffic', session.onRpcTraffic.bind(session));\n    session.on('closed', () => session.onSessionClosed());\n  }\n\n  /**\n  * Event handler for re-triggering error events from RPC.\n  * @private\n  * @emits socket-error\n  * @param {Error} err Webocket error event.\n  */\n  onRpcError(err) {\n    if (this.suspendResume.isSuspended) {\n      return;\n    }\n    this.emit('socket-error', err);\n  }\n\n  /**\n  * Event handler for the RPC close event.\n  * @private\n  * @emits Session#suspended\n  * @emits Session#closed\n  * @param {Event} evt WebSocket close event.\n  */\n  onRpcClosed(evt) {\n    /**\n     * Handles suspended state. This event is triggered in two cases (listed below). It is useful\n     * in scenarios where, for example, you want to block interaction with your application until\n     * you resume again. Or, if config.suspendOnClose is true and there was a network disconnect\n     * (socket closed) or if you ran session.suspend().\n     * @event Session#suspended\n     * @type {Object}\n     * @param {Object} evt Event object.\n     * @param {String} evt.initiator String indication what triggered the suspended state. Possible\n     * values network, manual.\n     * @example <caption>Handling session suspended</caption>\n     * session.on('suspended', () => {\n     *   console.log('Session was suspended, retrying...');\n     *   session.resume();\n     * });\n     */\n    if (this.suspendResume.isSuspended) {\n      return;\n    }\n    if (evt.code === RPC_CLOSE_NORMAL || evt.code === RPC_CLOSE_MANUAL_SUSPEND) {\n      return;\n    }\n    if (this.config.suspendOnClose) {\n      const { code, reason } = evt;\n      this.suspendResume.suspend().then(() => this.emit('suspended', {\n        initiator: 'network',\n        code,\n        reason,\n      }));\n    } else {\n      this.emit('closed', evt);\n    }\n  }\n\n  /**\n  * Event handler for the RPC message event.\n  * @private\n  * @param {Object} response JSONRPC response.\n  */\n  onRpcMessage(response) {\n    if (this.suspendResume.isSuspended) {\n      return;\n    }\n    if (response.change) {\n      response.change.forEach((handle) => this.emitHandleChanged(handle));\n    }\n    if (response.close) {\n      response.close.forEach((handle) => this.emitHandleClosed(handle));\n    }\n  }\n\n  /**\n  * Event handler for the RPC notification event.\n  * @private\n  * @emits Session#notification\n  * @param {Object} response The JSONRPC notification.\n  */\n  onRpcNotification(response) {\n    this.emit('notification:*', response.method, response.params);\n    this.emit(`notification:${response.method}`, response.params);\n  }\n\n  /**\n  * Event handler for the RPC traffic event.\n  * @private\n  * @emits Session#traffic\n  * @param {String} dir The traffic direction, sent or received.\n  * @param {Object} data JSONRPC request/response/WebSocket message.\n  * @param {Number} handle The associated handle.\n  */\n  onRpcTraffic(dir, data, handle) {\n    this.emit('traffic:*', dir, data);\n    this.emit(`traffic:${dir}`, data);\n    const api = this.apis.getApi(handle);\n    if (api) {\n      api.emit('traffic:*', dir, data);\n      api.emit(`traffic:${dir}`, data);\n    }\n  }\n\n  /**\n  * Event handler for cleaning up API instances when a session has been closed.\n  * @private\n  * @emits API#closed\n  */\n  onSessionClosed() {\n    this.apis.getApis().forEach((entry) => {\n      entry.api.emit('closed');\n      entry.api.removeAllListeners();\n    });\n    this.apis.clear();\n  }\n\n  /**\n   * Function used to get an API for a backend object.\n   * @private\n   * @param {Object} args Arguments used to create object API.\n   * @param {Number} args.handle Handle of the backend object.\n   * @param {String} args.id ID of the backend object.\n   * @param {String} args.type QIX type of the backend object. Can for example\n   *                           be \"Doc\" or \"GenericVariable\".\n   * @param {String} args.genericType Custom type of the backend object, if defined in qInfo.\n   * @returns {Object} Returns the generated and possibly augmented API.\n   */\n  getObjectApi(args) {\n    const {\n      handle, id, type, genericType,\n    } = args;\n    let api = this.apis.getApi(handle);\n    if (api) {\n      return api;\n    }\n    const factory = this.definition.generate(type);\n    api = factory(this, handle, id, genericType);\n    this.apis.add(handle, api);\n    return api;\n  }\n\n  /**\n  * Establishes the websocket against the configured URL and returns the Global instance.\n  * @emits Session#opened\n  * @returns {Promise<Object>} Eventually resolved if the connection was successful.\n  * @example <caption>Opening a sesssion</caption>\n  * session.open().then(() => {\n  *   console.log('Session was opened');\n  * });\n  */\n  open() {\n    /**\n     * Handles opened state. This event is triggered whenever the websocket is connected and\n     * ready for communication.\n     * @event Session#opened\n     * @type {Object}\n     * @example <caption>Bind the session opened event</caption>\n     * session.on('opened', () => {\n     *   console.log('Session was opened');\n     * });\n     */\n    if (!this.globalPromise) {\n      const args = {\n        handle: -1,\n        id: 'Global',\n        type: 'Global',\n        genericType: 'Global',\n      };\n      this.globalPromise = this.rpc.open()\n        .then(() => this.getObjectApi(args))\n        .then((global) => {\n          this.emit('opened');\n          return global;\n        });\n    }\n    return this.globalPromise;\n  }\n\n  /**\n  * Function used to send data on the RPC socket.\n  * @param {Object} request The request to be sent. (data and some meta info)\n  * @returns {Object} Returns a promise instance.\n  */\n  send(request) {\n    if (this.suspendResume.isSuspended) {\n      return this.Promise.reject(createEnigmaError(errorCodes.SESSION_SUSPENDED, 'Session suspended', this.rpc.closeEvent));\n    }\n    request.id = this.rpc.createRequestId();\n    const promise = this.intercept.executeRequests(this, this.Promise.resolve(request))\n      .then((augmentedRequest) => {\n        const data = { ...this.config.protocol, ...augmentedRequest };\n        // the outKey value is used by multiple-out interceptor, at some point\n        // we need to refactor that implementation and figure out how to transport\n        // this value without hijacking the JSONRPC request object:\n        delete data.outKey;\n        const response = this.rpc.send(data);\n        augmentedRequest.retry = () => this.send(request);\n        return this.intercept.executeResponses(this, response, augmentedRequest);\n      });\n    Session.addToPromiseChain(promise, 'requestId', request.id);\n    return promise;\n  }\n\n  /**\n  * Suspends the enigma.js session by closing the websocket and rejecting all method calls\n  * until it is has resumed again.\n  * @emits Session#suspended\n  * @param {Number} [code=4000] - The reason code for suspending the connection.\n  * @param {String} [reason=\"\"] - The human readable string describing\n  * why the connection is suspended.\n  * @returns {Promise<Object>} Eventually resolved when the websocket has been closed.\n  * @example <caption>Suspending a session</caption>\n  * session.suspend().then(() => {\n  *   console.log('Session was suspended');\n  * });\n  */\n  suspend(code = 4000, reason = '') {\n    return this.suspendResume.suspend(code, reason)\n      .then(() => this.emit('suspended', { initiator: 'manual', code, reason }));\n  }\n\n  /**\n  * Resumes a previously suspended enigma.js session by recreating the websocket and,\n  * if possible, reopen the document as well as refreshing the internal cashes. If successful,\n  * changed events will be triggered on all generated APIs, and on the ones it was unable to\n  * restore, the closed event will be triggered.\n  * @emits Session#resumed\n  * @param {Boolean} onlyIfAttached If true, resume only if the session was reattached properly.\n  * @returns {Promise<Object>} Eventually resolved when the websocket (and potentially the\n  * previously opened document, and generated APIs) has been restored; it is rejected when it fails\n  * any of those steps, or when onlyIfAttached is true and a new session was created.\n  * @example <caption>Resuming a session</caption>\n  * session.resume(true).then(() => {\n  *   console.log('Session was resumed by re-attaching');\n  * });\n  */\n  resume(onlyIfAttached) {\n    /**\n     * Handles resumed state. This event is triggered when the session was properly resumed. It is\n     * useful in scenarios where, for example, you can close blocking modal dialogs and allow the\n     * user to interact with your application again.\n     * @event Session#resumed\n     * @type {Object}\n     * @example <caption>Handling session resumed</caption>\n     * session.on('resumed', () => {\n     *   console.log('Session was resumed, we can close that \"reconnecting\" dialog now');\n     * });\n     */\n    return this.suspendResume.resume(onlyIfAttached).then((value) => {\n      this.emit('resumed');\n      return value;\n    });\n  }\n\n  /**\n  * Closes the websocket and cleans up internal caches. Also triggers the closed event\n  * on all generated APIs. Note that you have to manually invoke this when you want to\n  * close a session and config.suspendOnClose is true.\n  * @emits Session#closed\n  * @param {Number} [code=1000] - The reason code for closing the connection.\n  * @param {String} [reason=\"\"] - The human readable string describing why the connection is closed.\n  * @returns {Promise<Object>} Eventually resolved when the websocket has been closed.\n  * @example <caption>Closing a session</caption>\n  * session.close().then(() => {\n  *   console.log('Session was closed');\n  * });\n  */\n  close(code = 1000, reason = '') {\n    /**\n     * Handles closed state. This event is triggered when the underlying websocket is closed and\n     * config.suspendOnClose is false.\n     * @event Session#closed\n     * @type {Object}\n     * @example <caption>Handling session closed</caption>\n     * session.on('closed', () => {\n     *   console.log('Session was closed, clean up!');\n     * });\n     */\n    this.globalPromise = undefined;\n    return this.rpc.close(code, reason).then((evt) => this.emit('closed', evt));\n  }\n\n  /**\n  * Given a handle, this function will emit the 'changed' event on the\n  * corresponding API instance.\n  * @private\n  * @param {Number} handle The handle of the API instance.\n  * @emits API#changed\n  */\n  emitHandleChanged(handle) {\n    const api = this.apis.getApi(handle);\n    if (api) {\n      api.emit('changed');\n    }\n  }\n\n  /**\n  * Given a handle, this function will emit the 'closed' event on the\n  * corresponding API instance.\n  * @private\n  * @param {Number} handle The handle of the API instance.\n  * @emits API#closed\n  */\n  emitHandleClosed(handle) {\n    const api = this.apis.getApi(handle);\n    if (api) {\n      api.emit('closed');\n      api.removeAllListeners();\n    }\n  }\n\n  /**\n  * Function used to add info on the promise chain.\n  * @private\n  * @param {Promise<Object>} promise The promise to add info on.\n  * @param {String} name The property to add info on.\n  * @param {Any} value The info to add.\n  */\n  static addToPromiseChain(promise, name, value) {\n    promise[name] = value;\n    const { then } = promise;\n    promise.then = function patchedThen(...params) {\n      const chain = then.apply(this, params);\n      Session.addToPromiseChain(chain, name, value);\n      return chain;\n    };\n  }\n}\n\nexport default Session;\n","import createEnigmaError from './error';\nimport errorCodes from './error-codes';\n\n/**\n* Key-value cache\n* @private\n*/\nclass KeyValueCache {\n  constructor() {\n    this.entries = {};\n  }\n\n  /**\n  * Adds an entry.\n  * @private\n  * @function KeyValueCache#add\n  * @param {String} key The key representing an entry.\n  * @param {*} entry The entry to be added.\n  */\n  add(key, entry) {\n    key += '';\n    if (typeof this.entries[key] !== 'undefined') {\n      throw createEnigmaError(errorCodes.ENTRY_ALREADY_DEFINED, `Entry already defined with key ${key}`);\n    }\n    this.entries[key] = entry;\n  }\n\n  /**\n  * Sets an entry.\n  * @private\n  * @function KeyValueCache#set\n  * @param {String} key The key representing an entry.\n  * @param {*} entry The entry.\n  */\n  set(key, entry) {\n    key += '';\n    this.entries[key] = entry;\n  }\n\n  /**\n  * Removes an entry.\n  * @private\n  * @function KeyValueCache#remove\n  * @param {String} key The key representing an entry.\n  */\n  remove(key) {\n    delete this.entries[key];\n  }\n\n  /**\n  * Gets an entry.\n  * @private\n  * @function KeyValueCache#get\n  * @param {String} key The key representing an entry.\n  * @returns {*} The entry for the key.\n  */\n  get(key) {\n    return this.entries[key];\n  }\n\n  /**\n  * Gets a list of all entries.\n  * @private\n  * @function KeyValueCache#getAll\n  * @returns {Array} The list of entries including its `key` and `value` properties.\n  */\n  getAll() {\n    return Object.keys(this.entries).map((key) => ({\n      key,\n      value: this.entries[key],\n    }));\n  }\n\n  /**\n  * Gets a key for an entry.\n  * @private\n  * @function KeyValueCache#getKey\n  * @param {*} entry The entry to locate the key for.\n  * @returns {String} The key representing an entry.\n  */\n  getKey(entry) {\n    return Object.keys(this.entries).filter((key) => this.entries[key] === entry)[0];\n  }\n\n  /**\n  * Clears the cache of all entries.\n  * @private\n  * @function KeyValueCache#clear\n  */\n  clear() {\n    this.entries = {};\n  }\n}\n\nexport default KeyValueCache;\n","import KeyValueCache from './key-value-cache';\nimport Events from './event-emitter';\n\nimport createEnigmaError from './error';\nimport errorCodes from './error-codes';\n\nconst { hasOwnProperty } = Object.prototype;\n\n/**\n* Returns the camelCase counterpart of a symbol.\n* @private\n* @param {String} symbol The symbol.\n* @return the camelCase counterpart.\n*/\nfunction toCamelCase(symbol) {\n  return symbol.substring(0, 1).toLowerCase() + symbol.substring(1);\n}\n\n/**\n * A facade function that allows parameters to be passed either by name\n * (through an object), or by position (through an array).\n * @private\n * @param {Function} base The function that is being overriden. Will be\n *                        called with parameters in array-form.\n * @param {Object} defaults Parameter list and it's default values.\n * @param {*} params The parameters.\n */\nfunction namedParamFacade(base, defaults, ...params) {\n  if (params.length === 1 && typeof params[0] === 'object' && !Array.isArray(params[0])) {\n    const valid = Object.keys(params[0]).every((key) => hasOwnProperty.call(defaults, key));\n    if (valid) {\n      params = Object.keys(defaults).map((key) => params[0][key] || defaults[key]);\n    }\n  }\n  return base.apply(this, params);\n}\n\n/**\n* Qix schema definition.\n* @private\n*/\nclass Schema {\n  /**\n  * Create a new schema instance.\n  * @private\n  * @param {Configuration} config The configuration for QIX.\n  */\n  constructor(config) {\n    this.config = config;\n    this.Promise = config.Promise;\n    this.schema = config.schema;\n    this.mixins = new KeyValueCache();\n    this.types = new KeyValueCache();\n  }\n\n  registerMixin({\n    types, type, extend, override, init,\n  }) {\n    if (!Array.isArray(types)) {\n      types = [types];\n    }\n    // to support a single type\n    if (type) {\n      types.push(type);\n    }\n    const cached = { extend, override, init };\n    types.forEach((typeKey) => {\n      const entryList = this.mixins.get(typeKey);\n      if (entryList) {\n        entryList.push(cached);\n      } else {\n        this.mixins.add(typeKey, [cached]);\n      }\n    });\n  }\n\n  /**\n  * Function used to generate a type definition.\n  * @private\n  * @param {String} type The type.\n  * @returns {{create: Function, def: Object}} Returns an object with a definition\n  *          of the type and a create factory.\n  */\n  generate(type) {\n    const entry = this.types.get(type);\n    if (entry) {\n      return entry;\n    }\n    if (!this.schema.structs[type]) {\n      throw createEnigmaError(errorCodes.SCHEMA_STRUCT_TYPE_NOT_FOUND, `${type} not found`);\n    }\n    const factory = this.generateApi(type, this.schema.structs[type]);\n    this.types.add(type, factory);\n    return factory;\n  }\n\n  /**\n  * Function used to generate an API definition for a given type.\n  * @private\n  * @param {String} type The type to generate.\n  * @param {Object} schema The schema describing the type.\n  * @returns {{create: (function(session:Object, handle:Number, id:String,\n  *          customKey:String)), def: Object}} Returns the API definition.\n  */\n  generateApi(type, schema) {\n    const api = Object.create({});\n\n    this.generateDefaultApi(api, schema); // Generate default\n    this.mixinType(type, api); // Mixin default type\n    this.mixinNamedParamFacade(api, schema); // Mixin named parameter support\n\n    return function create(session, handle, id, customKey) {\n      const instance = Object.create(api);\n\n      Events.mixin(instance); // Always mixin event-emitter per instance\n\n      Object.defineProperties(instance, {\n        session: {\n          enumerable: true,\n          value: session,\n        },\n        handle: {\n          enumerable: true,\n          value: handle,\n          writable: true,\n        },\n        id: {\n          enumerable: true,\n          value: id,\n        },\n        type: {\n          enumerable: true,\n          value: type,\n        },\n        genericType: {\n          enumerable: true,\n          value: customKey,\n        },\n      });\n\n      let mixinList = this.mixins.get(type) || [];\n      if (customKey !== type) {\n        this.mixinType(customKey, instance); // Mixin custom types\n        mixinList = mixinList.concat(this.mixins.get(customKey) || []);\n      }\n      mixinList.forEach((mixin) => {\n        if (typeof mixin.init === 'function') {\n          mixin.init({ config: this.config, api: instance });\n        }\n      });\n\n      return instance;\n    }.bind(this);\n  }\n\n  /**\n  * Function used to generate the methods with the right handlers to the object\n  * API that is being generated.\n  * @private\n  * @param {Object} api The object API that is currently being generated.\n  * @param {Object} schema The API definition.\n  */\n  generateDefaultApi(api, schema) {\n    Object.keys(schema).forEach((method) => {\n      const out = schema[method].Out;\n      const outKey = out.length === 1 ? out[0].Name : -1;\n      const fnName = toCamelCase(method);\n\n      api[fnName] = function generatedMethod(...params) {\n        return this.session.send({\n          handle: this.handle,\n          method,\n          params,\n          outKey,\n        });\n      };\n    });\n  }\n\n  /**\n  * Function used to add mixin methods to a specified API.\n  * @private\n  * @param {String} type Used to specify which mixin should be woven in.\n  * @param {Object} api The object that will be woven.\n  */\n  mixinType(type, api) {\n    const mixinList = this.mixins.get(type);\n    if (mixinList) {\n      mixinList.forEach(({ extend = {}, override = {} }) => {\n        Object.keys(override).forEach((key) => {\n          if (typeof api[key] === 'function' && typeof override[key] === 'function') {\n            const baseFn = api[key];\n            api[key] = function wrappedFn(...args) {\n              return override[key].apply(this, [baseFn.bind(this), ...args]);\n            };\n          } else {\n            throw createEnigmaError(errorCodes.SCHEMA_MIXIN_CANT_OVERRIDE_FUNCTION, `No function to override. Type: ${type} function: ${key}`);\n          }\n        });\n        Object.keys(extend).forEach((key) => {\n          // handle overrides\n          if (typeof api[key] === 'function' && typeof extend[key] === 'function') {\n            throw createEnigmaError(errorCodes.SCHEMA_MIXIN_EXTEND_NOT_ALLOWED, `Extend is not allowed for this mixin. Type: ${type} function: ${key}`);\n          } else {\n            api[key] = extend[key];\n          }\n        });\n      });\n    }\n  }\n\n  /**\n  * Function used to mixin the named parameter facade.\n  * @private\n  * @param {Object} api The object API that is currently being generated.\n  * @param {Object} schema The API definition.\n  */\n  mixinNamedParamFacade(api, schema) {\n    Object.keys(schema).forEach((key) => {\n      const fnName = toCamelCase(key);\n      const base = api[fnName];\n      const defaults = schema[key].In.reduce((result, item) => {\n        result[item.Name] = item.DefaultValue;\n        return result;\n      }, {});\n\n      api[fnName] = function namedParamWrapper(...params) {\n        return namedParamFacade.apply(this, [base, defaults, ...params]);\n      };\n    });\n  }\n}\n\nexport default Schema;\n","import Events from './event-emitter';\n\n/**\n * Helper class for handling RPC calls\n * @private\n */\nclass RPCResolver {\n  constructor(id, handle, resolve, reject) {\n    Events.mixin(this);\n    this.id = id;\n    this.handle = handle;\n    this.resolve = resolve;\n    this.reject = reject;\n  }\n\n  resolveWith(data) {\n    this.resolve(data);\n    this.emit('resolved', this.id);\n  }\n\n  rejectWith(err) {\n    this.reject(err);\n    this.emit('rejected', this.id);\n  }\n}\n\nexport default RPCResolver;\n","import Events from './event-emitter';\nimport RPCResolver from './rpc-resolver';\n\nimport createEnigmaError from './error';\nimport errorCodes from './error-codes';\n\n/**\n* This class handles remote procedure calls on a web socket.\n* @private\n*/\nclass RPC {\n  /**\n  * Create a new RPC instance.\n  * @private\n  * @param {Object} options The configuration options for this class.\n  * @param {Function} options.Promise The promise constructor to use.\n  * @param {String} options.url The complete websocket URL used to connect.\n  * @param {Function} options.createSocket The function callback to create a WebSocket.\n  */\n  constructor(options) {\n    Object.assign(this, options);\n    Events.mixin(this);\n    this.resolvers = {};\n    this.requestId = 0;\n    this.openedPromise = undefined;\n    this.closeEvent = undefined;\n  }\n\n  /**\n  * Opens a connection to the configured endpoint.\n  * @private\n  * @param {Boolean} force - ignores all previous and outstanding open calls if set to true.\n  * @returns {Object} A promise instance.\n  */\n  open(force = false) {\n    if (!force && this.openedPromise) {\n      return this.openedPromise;\n    }\n\n    try {\n      this.socket = this.createSocket(this.url);\n    } catch (err) {\n      return this.Promise.reject(err);\n    }\n\n    this.socket.onopen = this.onOpen.bind(this);\n    this.socket.onclose = this.onClose.bind(this);\n    this.socket.onerror = this.onError.bind(this);\n    this.socket.onmessage = this.onMessage.bind(this);\n    this.openedPromise = new this.Promise((resolve, reject) => this.registerResolver('opened', null, resolve, reject));\n    this.closedPromise = new this.Promise((resolve, reject) => this.registerResolver('closed', null, resolve, reject));\n    return this.openedPromise;\n  }\n\n  /**\n  * Resolves the open promise when a connection is successfully established.\n  * @private\n  */\n  onOpen() {\n    this.resolvers.opened.resolveWith(() => this.closedPromise);\n  }\n\n  /**\n  * Resolves the close promise when a connection is closed.\n  * @private\n  * @param {Object} event - The event describing close.\n  */\n  onClose(event) {\n    this.emit('closed', event);\n    this.closeEvent = event;\n    if (this.resolvers && this.resolvers.closed) {\n      this.resolvers.closed.resolveWith(event);\n    }\n    this.rejectAllOutstandingResolvers(createEnigmaError(errorCodes.NOT_CONNECTED, 'Socket closed', event));\n  }\n\n  /**\n  * Closes a connection.\n  * @private\n  * @param {Number} [code=1000] - The reason code for closing the connection.\n  * @param {String} [reason=\"\"] - The human readable string describing why the connection is closed.\n  * @returns {Object} Returns a promise instance.\n  */\n  close(code = 1000, reason = '') {\n    if (this.socket) {\n      this.socket.close(code, reason);\n      this.socket = null;\n    }\n    return this.closedPromise;\n  }\n\n  /**\n  * Emits an error event and rejects the open promise if an error is raised on the connection.\n  * @private\n  * @param {Object} event - The event describing the error.\n  */\n  onError(event) {\n    if (this.resolvers.opened) {\n      this.resolvers.opened.rejectWith(event);\n    } else {\n      // only emit errors after the initial open promise has been resolved,\n      // this makes it possible to catch early websocket errors as well\n      // as run-time ones:\n      this.emit('socket-error', event);\n    }\n    this.rejectAllOutstandingResolvers(createEnigmaError(errorCodes.NOT_CONNECTED, 'Socket error', event));\n  }\n\n  /**\n  * Parses the onMessage event on the connection and resolve the promise for the request.\n  * @private\n  * @param {Object} event - The event describing the message.\n  */\n  onMessage(event) {\n    const data = JSON.parse(event.data);\n    const resolver = this.resolvers[data.id] || {};\n    this.emit('traffic', 'received', data, resolver.handle);\n    if (typeof data.id !== 'undefined' && this.resolvers[data.id]) {\n      this.emit('message', data);\n      this.resolvers[data.id].resolveWith(data);\n    } else {\n      this.emit(data.params ? 'notification' : 'message', data);\n    }\n  }\n\n  /**\n  * Rejects all outstanding resolvers.\n  * @private\n  * @param {Object} reason - The reject reason.\n  */\n  rejectAllOutstandingResolvers(reason) {\n    Object.keys(this.resolvers).forEach((id) => {\n      if (id === 'opened' || id === 'closed') {\n        return; // \"opened\" and \"closed\" should not be handled here\n      }\n      const resolver = this.resolvers[id];\n      resolver.rejectWith(reason);\n    });\n  }\n\n  /**\n  * Unregisters a resolver.\n  * @private\n  * @param {Number|String} id - The ID to unregister the resolver with.\n  */\n  unregisterResolver(id) {\n    const resolver = this.resolvers[id];\n    resolver.removeAllListeners();\n    delete this.resolvers[id];\n  }\n\n  /**\n  * Registers a resolver.\n  * @private\n  * @param {Number|String} id - The ID to register the resolver with.\n  * @param {Number} handle - The associated handle.\n  * @returns {Function} The promise executor function.\n  */\n  registerResolver(id, handle, resolve, reject) {\n    const resolver = new RPCResolver(id, handle, resolve, reject);\n    this.resolvers[id] = resolver;\n    resolver.on('resolved', (resolvedId) => this.unregisterResolver(resolvedId));\n    resolver.on('rejected', (rejectedId) => this.unregisterResolver(rejectedId));\n  }\n\n  /**\n  * Sends data on the socket.\n  * @private\n  * @param {Object} data - The data to send.\n  * @returns {Object} A promise instance.\n  */\n  send(data) {\n    if (!this.socket || this.socket.readyState !== this.socket.OPEN) {\n      const error = createEnigmaError(errorCodes.NOT_CONNECTED, 'Not connected', this.closeEvent);\n      return this.Promise.reject(error);\n    }\n    if (!data.id) {\n      data.id = this.createRequestId();\n    }\n    data.jsonrpc = '2.0';\n    return new this.Promise((resolve, reject) => {\n      this.socket.send(JSON.stringify(data));\n      this.emit('traffic', 'sent', data, data.handle);\n      return this.registerResolver(data.id, data.handle, resolve, reject);\n    });\n  }\n\n  createRequestId() {\n    this.requestId += 1;\n    return this.requestId;\n  }\n}\n\nexport default RPC;\n","import createEnigmaError from './error';\nimport errorCodes from './error-codes';\n\nconst ON_ATTACHED_TIMEOUT_MS = 5000;\nconst RPC_CLOSE_MANUAL_SUSPEND = 4000;\n\nclass SuspendResume {\n  /**\n  * Creates a new SuspendResume instance.\n  * @private\n  * @param {Object} options The configuration option for this class.\n  * @param {Promise<Object>} options.Promise The promise constructor to use.\n  * @param {RPC} options.rpc The RPC instance to use when communicating towards Engine.\n  * @param {ApiCache} options.apis The ApiCache instance to use.\n  */\n  constructor(options) {\n    Object.assign(this, options);\n    this.isSuspended = false;\n    this.rpc.on('traffic', (dir, data) => {\n      if (dir === 'sent' && data.method === 'OpenDoc') {\n        this.openDocParams = data.params;\n      }\n    });\n  }\n\n  /**\n  * Function used to restore the rpc connection.\n  * @private\n  * @param {Boolean} onlyIfAttached - if true, the returned promise will resolve\n  *                                   only if the session can be re-attached.\n  * @returns {Object} Returns a promise instance.\n  */\n  restoreRpcConnection(onlyIfAttached) {\n    return this.reopen(ON_ATTACHED_TIMEOUT_MS).then((sessionState) => {\n      if (sessionState === 'SESSION_CREATED' && onlyIfAttached) {\n        return this.Promise.reject(createEnigmaError(errorCodes.SESSION_NOT_ATTACHED, 'Not attached'));\n      }\n      return this.Promise.resolve();\n    });\n  }\n\n  /**\n  * Function used to restore the global API.\n  * @private\n  * @param {Object} changed - A list where the restored APIs will be added.\n  * @returns {Object} Returns a promise instance.\n  */\n  restoreGlobal(changed) {\n    const global = this.apis.getApisByType('Global').pop();\n    changed.push(global.api);\n    return this.Promise.resolve();\n  }\n\n  /**\n  * Function used to restore the doc API.\n  * @private\n  * @param {String} sessionState - The state of the session, attached or created.\n  * @param {Array} closed - A list where the closed of APIs APIs will be added.\n  * @param {Object} changed - A list where the restored APIs will be added.\n  * @returns {Object} Returns a promise instance.\n  */\n  restoreDoc(closed, changed) {\n    const doc = this.apis.getApisByType('Doc').pop();\n\n    if (!doc) {\n      return this.Promise.resolve();\n    }\n\n    return this.rpc.send({\n      method: 'GetActiveDoc',\n      handle: -1,\n      params: [],\n    }).then((response) => {\n      if (response.error && this.openDocParams) {\n        return this.rpc.send({\n          method: 'OpenDoc',\n          handle: -1,\n          params: this.openDocParams,\n        });\n      }\n      return response;\n    }).then((response) => {\n      if (response.error) {\n        closed.push(doc.api);\n        return this.Promise.resolve();\n      }\n      const handle = response.result.qReturn.qHandle;\n      doc.api.handle = handle;\n      changed.push(doc.api);\n      return this.Promise.resolve(doc.api);\n    });\n  }\n\n  /**\n  * Function used to restore the APIs on the doc.\n  * @private\n  * @param {Object} doc - The doc API on which the APIs we want to restore exist.\n  * @param {Array} closed - A list where the closed of APIs APIs will be added.\n  * @param {Object} changed - A list where the restored APIs will be added.\n  * @returns {Object} Returns a promise instance.\n  */\n  restoreDocObjects(doc, closed, changed) {\n    const tasks = [];\n    const apis = this.apis.getApis()\n      .map((entry) => entry.api)\n      .filter((api) => api.type !== 'Global' && api.type !== 'Doc');\n\n    if (!doc) {\n      apis.forEach((api) => closed.push(api));\n      return this.Promise.resolve();\n    }\n\n    apis.forEach((api) => {\n      const method = SuspendResume.buildGetMethodName(api.type);\n\n      if (!method) {\n        closed.push(api);\n      } else {\n        const request = this.rpc.send({\n          method,\n          handle: doc.handle,\n          params: [api.id],\n        }).then((response) => {\n          if (response.error || !response.result.qReturn.qHandle) {\n            closed.push(api);\n          } else {\n            api.handle = response.result.qReturn.qHandle;\n            changed.push(api);\n          }\n        });\n        tasks.push(request);\n      }\n    });\n    return this.Promise.all(tasks);\n  }\n\n  /**\n  * Set the instance as suspended.\n  * @private\n  * @param {Number} [code=4000] - The reason code for suspending the connection.\n  * @param {String} [reason=\"\"] - The human readable string describing\n  * why the connection is suspended.\n  */\n  suspend(code = RPC_CLOSE_MANUAL_SUSPEND, reason = '') {\n    this.isSuspended = true;\n    return this.rpc.close(code, reason);\n  }\n\n  /**\n  * Resumes a previously suspended RPC connection, and refreshes the API cache.\n  *                                APIs unabled to be restored has their 'closed'\n  *                                event triggered, otherwise 'changed'.\n  * @private\n  * @emits API#changed\n  * @emits APIfunction@#closed\n  * @param {Boolean} onlyIfAttached if true, resume only if the session was re-attached.\n  * @returns {Promise<Object>} Eventually resolved if the RPC connection was successfully resumed,\n  *                    otherwise rejected.\n  */\n  resume(onlyIfAttached) {\n    const changed = [];\n    const closed = [];\n\n    return this.restoreRpcConnection(onlyIfAttached)\n      .then(() => this.restoreGlobal(changed))\n      .then(() => this.restoreDoc(closed, changed))\n      .then((doc) => this.restoreDocObjects(doc, closed, changed))\n      .then(() => {\n        this.isSuspended = false;\n        this.apis.clear();\n        closed.forEach((api) => {\n          api.emit('closed');\n          api.removeAllListeners();\n        });\n        changed.forEach((api) => {\n          this.apis.add(api.handle, api);\n          if (api.type !== 'Global') {\n            api.emit('changed');\n          }\n        });\n      })\n      .catch((err) => this.rpc.close().then(() => this.Promise.reject(err)));\n  }\n\n  /**\n  * Reopens the connection and waits for the OnConnected notification.\n  * @private\n  * @param {Number} timeout - The time to wait for the OnConnected notification.\n  * @returns {Object} A promise containing the session state (SESSION_CREATED or SESSION_ATTACHED).\n  */\n  reopen(timeout) {\n    let timer;\n    let notificationResolve;\n    let notificationReceived = false;\n    const notificationPromise = new this.Promise((resolve) => { notificationResolve = resolve; });\n\n    const waitForNotification = () => {\n      if (!notificationReceived) {\n        timer = setTimeout(() => notificationResolve('SESSION_CREATED'), timeout);\n      }\n      return notificationPromise;\n    };\n\n    const onNotification = (data) => {\n      if (data.method !== 'OnConnected') return;\n      clearTimeout(timer);\n      notificationResolve(data.params.qSessionState);\n      notificationReceived = true;\n    };\n\n    this.rpc.on('notification', onNotification);\n\n    return this.rpc.open(true)\n      .then(waitForNotification)\n      .then((state) => {\n        this.rpc.removeListener('notification', onNotification);\n        return state;\n      })\n      .catch((err) => {\n        this.rpc.removeListener('notification', onNotification);\n        return this.Promise.reject(err);\n      });\n  }\n\n  /**\n  * Function used to build the get method names for Doc APIs.\n  * @private\n  * @param {String} type - The API type.\n  * @returns {String} Returns the get method name, or undefined if the type cannot be restored.\n  */\n  static buildGetMethodName(type) {\n    if (type === 'Field' || type === 'Variable') {\n      return null;\n    }\n    if (type === 'GenericVariable') {\n      return 'GetVariableById';\n    }\n    return type.replace('Generic', 'Get');\n  }\n}\n\nexport default SuspendResume;\n","const SUCCESS_KEY = 'qSuccess';\n\nexport default function deltaRequestInterceptor(session, request) {\n  const delta = session.config.protocol.delta\n    && request.outKey !== -1\n    && request.outKey !== SUCCESS_KEY;\n  if (delta) {\n    request.delta = delta;\n  }\n  return request;\n}\n","import createEnigmaError from '../error';\nimport errorCodes from '../error-codes';\n\n/**\n* Response interceptor for generating APIs. Handles the quirks of engine not\n* returning an error when an object is missing.\n* @private\n* @param {Session} session - The session the intercept is being executed on.\n* @param {Object} request - The JSON-RPC request.\n* @param {Object} response - The response.\n* @returns {Object} - Returns the generated API\n*/\nexport default function apiResponseInterceptor(session, request, response) {\n  if (response && response.qHandle && response.qType) {\n    return session.getObjectApi({\n      handle: response.qHandle,\n      type: response.qType,\n      id: response.qGenericId,\n      genericType: response.qGenericType,\n    });\n  }\n  if (response && response.qHandle === null && response.qType === null) {\n    const error = createEnigmaError(errorCodes.OBJECT_NOT_FOUND, 'Object not found');\n    return session.config.Promise.reject(error);\n  }\n  return response;\n}\n","'use strict';\n\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar toStr = Object.prototype.toString;\nvar defineProperty = Object.defineProperty;\nvar gOPD = Object.getOwnPropertyDescriptor;\n\nvar isArray = function isArray(arr) {\n\tif (typeof Array.isArray === 'function') {\n\t\treturn Array.isArray(arr);\n\t}\n\n\treturn toStr.call(arr) === '[object Array]';\n};\n\nvar isPlainObject = function isPlainObject(obj) {\n\tif (!obj || toStr.call(obj) !== '[object Object]') {\n\t\treturn false;\n\t}\n\n\tvar hasOwnConstructor = hasOwn.call(obj, 'constructor');\n\tvar hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');\n\t// Not own constructor property must be Object\n\tif (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {\n\t\treturn false;\n\t}\n\n\t// Own properties are enumerated firstly, so to speed up,\n\t// if last one is own, then all properties are own.\n\tvar key;\n\tfor (key in obj) { /**/ }\n\n\treturn typeof key === 'undefined' || hasOwn.call(obj, key);\n};\n\n// If name is '__proto__', and Object.defineProperty is available, define __proto__ as an own property on target\nvar setProperty = function setProperty(target, options) {\n\tif (defineProperty && options.name === '__proto__') {\n\t\tdefineProperty(target, options.name, {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\t\t\tvalue: options.newValue,\n\t\t\twritable: true\n\t\t});\n\t} else {\n\t\ttarget[options.name] = options.newValue;\n\t}\n};\n\n// Return undefined instead of __proto__ if '__proto__' is not an own property\nvar getProperty = function getProperty(obj, name) {\n\tif (name === '__proto__') {\n\t\tif (!hasOwn.call(obj, name)) {\n\t\t\treturn void 0;\n\t\t} else if (gOPD) {\n\t\t\t// In early versions of node, obj['__proto__'] is buggy when obj has\n\t\t\t// __proto__ as an own property. Object.getOwnPropertyDescriptor() works.\n\t\t\treturn gOPD(obj, name).value;\n\t\t}\n\t}\n\n\treturn obj[name];\n};\n\nmodule.exports = function extend() {\n\tvar options, name, src, copy, copyIsArray, clone;\n\tvar target = arguments[0];\n\tvar i = 1;\n\tvar length = arguments.length;\n\tvar deep = false;\n\n\t// Handle a deep copy situation\n\tif (typeof target === 'boolean') {\n\t\tdeep = target;\n\t\ttarget = arguments[1] || {};\n\t\t// skip the boolean and the target\n\t\ti = 2;\n\t}\n\tif (target == null || (typeof target !== 'object' && typeof target !== 'function')) {\n\t\ttarget = {};\n\t}\n\n\tfor (; i < length; ++i) {\n\t\toptions = arguments[i];\n\t\t// Only deal with non-null/undefined values\n\t\tif (options != null) {\n\t\t\t// Extend the base object\n\t\t\tfor (name in options) {\n\t\t\t\tsrc = getProperty(target, name);\n\t\t\t\tcopy = getProperty(options, name);\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif (target !== copy) {\n\t\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\t\tif (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {\n\t\t\t\t\t\tif (copyIsArray) {\n\t\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\t\tclone = src && isArray(src) ? src : [];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tclone = src && isPlainObject(src) ? src : {};\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\t\tsetProperty(target, { name: name, newValue: extend(deep, clone, copy) });\n\n\t\t\t\t\t// Don't bring in undefined values\n\t\t\t\t\t} else if (typeof copy !== 'undefined') {\n\t\t\t\t\t\tsetProperty(target, { name: name, newValue: copy });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n","import originalExtend from 'extend';\n\nimport createEnigmaError from './error';\nimport errorCodes from './error-codes';\n\nconst extend = originalExtend.bind(null, true);\nconst JSONPatch = {};\nconst { isArray } = Array;\nfunction isObject(v) { return v != null && !Array.isArray(v) && typeof v === 'object'; }\nfunction isUndef(v) { return typeof v === 'undefined'; }\nfunction isFunction(v) { return typeof v === 'function'; }\n\n/**\n* Generate an exact duplicate (with no references) of a specific value.\n*\n* @private\n* @param {Object} The value to duplicate\n* @returns {Object} a unique, duplicated value\n*/\nfunction generateValue(val) {\n  if (val) {\n    return extend({}, { val }).val;\n  }\n  return val;\n}\n\n/**\n* An additional type checker used to determine if the property is of internal\n* use or not a type that can be translated into JSON (like functions).\n*\n* @private\n* @param {Object} obj The object which has the property to check\n* @param {String} The property name to check\n* @returns {Boolean} Whether the property is deemed special or not\n*/\nfunction isSpecialProperty(obj, key) {\n  return isFunction(obj[key])\n    || key.substring(0, 2) === '$$'\n    || key.substring(0, 1) === '_';\n}\n\n/**\n* Finds the parent object from a JSON-Pointer (\"/foo/bar/baz\" = \"bar\" is \"baz\" parent),\n* also creates the object structure needed.\n*\n* @private\n* @param {Object} data The root object to traverse through\n* @param {String} The JSON-Pointer string to use when traversing\n* @returns {Object} The parent object\n*/\nfunction getParent(data, str) {\n  const seperator = '/';\n  const parts = str.substring(1).split(seperator).slice(0, -1);\n  let numPart;\n\n  parts.forEach((part, i) => {\n    if (i === parts.length) {\n      return;\n    }\n    numPart = +part;\n    const newPart = !isNaN(numPart) ? [] : {};\n    data[numPart || part] = isUndef(data[numPart || part])\n      ? newPart\n      : data[part];\n    data = data[numPart || part];\n  });\n\n  return data;\n}\n\n/**\n* Cleans an object of all its properties, unless they're deemed special or\n* cannot be removed by configuration.\n*\n* @private\n* @param {Object} obj The object to clean\n*/\nfunction emptyObject(obj) {\n  Object.keys(obj).forEach((key) => {\n    const config = Object.getOwnPropertyDescriptor(obj, key);\n\n    if (config.configurable && !isSpecialProperty(obj, key)) {\n      delete obj[key];\n    }\n  });\n}\n\n/**\n* Compare an object with another, could be object, array, number, string, bool.\n* @private\n* @param {Object} a The first object to compare\n* @param {Object} a The second object to compare\n* @returns {Boolean} Whether the objects are identical\n*/\nfunction compare(a, b) {\n  let isIdentical = true;\n\n  if (isObject(a) && isObject(b)) {\n    if (Object.keys(a).length !== Object.keys(b).length) {\n      return false;\n    }\n    Object.keys(a).forEach((key) => {\n      if (!compare(a[key], b[key])) {\n        isIdentical = false;\n      }\n    });\n    return isIdentical;\n  }\n  if (isArray(a) && isArray(b)) {\n    if (a.length !== b.length) {\n      return false;\n    }\n    for (let i = 0, l = a.length; i < l; i += 1) {\n      if (!compare(a[i], b[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return a === b;\n}\n\n/**\n* Generates patches by comparing two arrays.\n*\n* @private\n* @param {Array} oldA The old (original) array, which will be patched\n* @param {Array} newA The new array, which will be used to compare against\n* @returns {Array} An array of patches (if any)\n*/\nfunction patchArray(original, newA, basePath) {\n  let patches = [];\n  const oldA = original.slice();\n  let tmpIdx = -1;\n\n  function findIndex(a, id, idx) {\n    if (a[idx] && isUndef(a[idx].qInfo)) {\n      return null;\n    }\n    if (a[idx] && a[idx].qInfo.qId === id) {\n      // shortcut if identical\n      return idx;\n    }\n    for (let ii = 0, ll = a.length; ii < ll; ii += 1) {\n      if (a[ii] && a[ii].qInfo.qId === id) {\n        return ii;\n      }\n    }\n    return -1;\n  }\n\n  if (compare(newA, oldA)) {\n    // array is unchanged\n    return patches;\n  }\n\n  if (!isUndef(newA[0]) && isUndef(newA[0].qInfo)) {\n    // we cannot create patches without unique identifiers, replace array...\n    patches.push({\n      op: 'replace',\n      path: basePath,\n      value: newA,\n    });\n    return patches;\n  }\n\n  for (let i = oldA.length - 1; i >= 0; i -= 1) {\n    tmpIdx = findIndex(newA, oldA[i].qInfo && oldA[i].qInfo.qId, i);\n    if (tmpIdx === -1) {\n      patches.push({\n        op: 'remove',\n        path: `${basePath}/${i}`,\n      });\n      oldA.splice(i, 1);\n    } else {\n      patches = patches.concat(JSONPatch.generate(oldA[i], newA[tmpIdx], `${basePath}/${i}`));\n    }\n  }\n\n  for (let i = 0, l = newA.length; i < l; i += 1) {\n    tmpIdx = findIndex(oldA, newA[i].qInfo && newA[i].qInfo.qId);\n    if (tmpIdx === -1) {\n      patches.push({\n        op: 'add',\n        path: `${basePath}/${i}`,\n        value: newA[i],\n      });\n      oldA.splice(i, 0, newA[i]);\n    } else if (tmpIdx !== i) {\n      patches.push({\n        op: 'move',\n        path: `${basePath}/${i}`,\n        from: `${basePath}/${tmpIdx}`,\n      });\n      oldA.splice(i, 0, oldA.splice(tmpIdx, 1)[0]);\n    }\n  }\n  return patches;\n}\n\n/**\n* Generate an array of JSON-Patch:es following the JSON-Patch Specification Draft.\n*\n* See [specification draft](http://tools.ietf.org/html/draft-ietf-appsawg-json-patch-10)\n*\n* Does NOT currently generate patches for arrays (will replace them)\n* @private\n* @param {Object} original The object to patch to\n* @param {Object} newData The object to patch from\n* @param {String} [basePath] The base path to use when generating the paths for\n*                            the patches (normally not used)\n* @returns {Array} An array of patches\n*/\nJSONPatch.generate = function generate(original, newData, basePath) {\n  basePath = basePath || '';\n  let patches = [];\n\n  Object.keys(newData).forEach((key) => {\n    const val = generateValue(newData[key]);\n    const oldVal = original[key];\n    const tmpPath = `${basePath}/${key}`;\n\n    if (compare(val, oldVal) || isSpecialProperty(newData, key)) {\n      return;\n    }\n    if (isUndef(oldVal)) {\n      // property does not previously exist\n      patches.push({\n        op: 'add',\n        path: tmpPath,\n        value: val,\n      });\n    } else if (isObject(val) && isObject(oldVal)) {\n      // we need to generate sub-patches for this, since it already exist\n      patches = patches.concat(JSONPatch.generate(oldVal, val, tmpPath));\n    } else if (isArray(val) && isArray(oldVal)) {\n      patches = patches.concat(patchArray(oldVal, val, tmpPath));\n    } else {\n      // it's a simple property (bool, string, number)\n      patches.push({\n        op: 'replace',\n        path: `${basePath}/${key}`,\n        value: val,\n      });\n    }\n  });\n\n  Object.keys(original).forEach((key) => {\n    if (isUndef(newData[key]) && !isSpecialProperty(original, key)) {\n      // this property does not exist anymore\n      patches.push({\n        op: 'remove',\n        path: `${basePath}/${key}`,\n      });\n    }\n  });\n\n  return patches;\n};\n\n/**\n* Apply a list of patches to an object.\n* @private\n* @param {Object} original The object to patch\n* @param {Array} patches The list of patches to apply\n*/\nJSONPatch.apply = function apply(original, patches) {\n  patches.forEach((patch) => {\n    let parent = getParent(original, patch.path);\n    let key = patch.path.split('/').splice(-1)[0];\n    let target = key && isNaN(+key) ? parent[key] : parent[+key] || parent;\n    const from = patch.from ? patch.from.split('/').splice(-1)[0] : null;\n\n    if (patch.path === '/') {\n      parent = null;\n      target = original;\n    }\n\n    if (patch.op === 'add' || patch.op === 'replace') {\n      if (isArray(parent)) {\n        // trust indexes from patches, so don't replace the index if it's an add\n        if (key === '-') {\n          key = parent.length;\n        }\n        parent.splice(+key, patch.op === 'add' ? 0 : 1, patch.value);\n      } else if (isArray(target) && isArray(patch.value)) {\n        // keep array reference if possible...\n        target.length = 0;\n\n        const chunkSize = 1000;\n        for (let i = 0; i < patch.value.length; i += chunkSize) {\n          const chunk = patch.value.slice(i, i + chunkSize);\n          target.push(...chunk);\n        }\n      } else if (isObject(target) && isObject(patch.value)) {\n        // keep object reference if possible...\n        emptyObject(target);\n        extend(target, patch.value);\n      } else if (!parent) {\n        throw createEnigmaError(errorCodes.PATCH_HAS_NO_PARENT, 'Patchee is not an object we can patch');\n      } else {\n        // simple value\n        parent[key] = patch.value;\n      }\n    } else if (patch.op === 'move') {\n      const oldParent = getParent(original, patch.from);\n      if (isArray(parent)) {\n        parent.splice(+key, 0, oldParent.splice(+from, 1)[0]);\n      } else {\n        parent[key] = oldParent[from];\n        delete oldParent[from];\n      }\n    } else if (patch.op === 'remove') {\n      if (isArray(parent)) {\n        parent.splice(+key, 1);\n      } else {\n        delete parent[key];\n      }\n    }\n  });\n};\n\n/**\n* Deep clone an object.\n* @private\n* @param {Object} obj The object to clone\n* @returns {Object} A new object identical to the `obj`\n*/\nJSONPatch.clone = function clone(obj) {\n  return extend({}, obj);\n};\n\n/**\n* Creates a JSON-patch.\n* @private\n* @param {String} op The operation of the patch. Available values: \"add\", \"remove\", \"move\"\n* @param {Object} [val] The value to set the `path` to. If `op` is `move`, `val`\n*                       is the \"from JSON-path\" path\n* @param {String} path The JSON-path for the property to change (e.g. \"/qHyperCubeDef/columnOrder\")\n* @returns {Object} A patch following the JSON-patch specification\n*/\nJSONPatch.createPatch = function createPatch(op, val, path) {\n  const patch = {\n    op: op.toLowerCase(),\n    path,\n  };\n  if (patch.op === 'move') {\n    patch.from = val;\n  } else if (typeof val !== 'undefined') {\n    patch.value = val;\n  }\n  return patch;\n};\n\n/**\n* Apply the differences of two objects (keeping references if possible).\n* Identical to running `JSONPatch.apply(original, JSONPatch.generate(original, newData));`\n* @private\n* @param {Object} original The object to update/patch\n* @param {Object} newData the object to diff against\n*\n* @example\n* var obj1 = { foo: [1,2,3], bar: { baz: true, qux: 1 } };\n* var obj2 = { foo: [4,5,6], bar: { baz: false } };\n* JSONPatch.updateObject(obj1, obj2);\n* // => { foo: [4,5,6], bar: { baz: false } };\n*/\nJSONPatch.updateObject = function updateObject(original, newData) {\n  if (!Object.keys(original).length) {\n    extend(original, newData);\n    return;\n  }\n  JSONPatch.apply(original, JSONPatch.generate(original, newData));\n};\n\nexport default JSONPatch;\n","import JSONPatch from '../json-patch';\nimport KeyValueCache from '../key-value-cache';\n\nimport createEnigmaError from '../error';\nimport errorCodes from '../error-codes';\n\nconst sessions = {};\n\n/**\n* Function to make sure we release handle caches when they are closed.\n* @private\n* @param {Session} session The session instance to listen on.\n*/\nconst bindSession = (session) => {\n  if (!sessions[session.id]) {\n    const cache = {};\n    sessions[session.id] = cache;\n    session.on('traffic:received', (data) => data.close && data.close.forEach((handle) => delete cache[handle]));\n    session.on('closed', () => delete sessions[session.id]);\n  }\n};\n\n/**\n* Simple function that ensures the session events has been bound, and returns\n* either an existing key-value cache or creates one for the specified handle.\n* @private\n* @param {Session} session The session that owns the handle.\n* @param {Number} handle The object handle to retrieve the cache for.\n* @returns {KeyValueCache} The cache instance.\n*/\nconst getHandleCache = (session, handle) => {\n  bindSession(session);\n  const cache = sessions[session.id];\n  if (!cache[handle]) {\n    cache[handle] = new KeyValueCache();\n  }\n  return cache[handle];\n};\n\n/**\n* Function used to apply a list of patches and return the patched value.\n* @private\n* @param {Session} session The session.\n* @param {Number} handle The object handle.\n* @param {String} cacheId The cacheId.\n* @param {Array} patches The patches.\n* @returns {Object} Returns the patched value.\n*/\nconst patchValue = (session, handle, cacheId, patches) => {\n  const cache = getHandleCache(session, handle);\n  let entry = cache.get(cacheId);\n  if (typeof entry === 'undefined') {\n    entry = Array.isArray(patches[0].value) ? [] : {};\n  }\n  if (patches.length) {\n    if (patches[0].path === '/' && typeof patches[0].value !== 'object') {\n      // 'plain' values on root path is not supported (no object reference),\n      // so we simply store the value directly:\n      entry = patches[0].value;\n    } else {\n      JSONPatch.apply(entry, patches);\n    }\n    cache.set(cacheId, entry);\n  }\n  return entry;\n};\n\n/**\n* Process delta interceptor.\n* @private\n* @param {Session} session The session the intercept is being executed on.\n* @param {Object} request The JSON-RPC request.\n* @param {Object} response The response.\n* @returns {Object} Returns the patched response\n*/\nexport default function deltaResponseInterceptor(session, request, response) {\n  const { delta, result } = response;\n  if (delta) {\n    // when delta is on the response data is expected to be an array of patches:\n    Object.keys(result).forEach((key) => {\n      if (!Array.isArray(result[key])) {\n        throw createEnigmaError(errorCodes.EXPECTED_ARRAY_OF_PATCHES, 'Unexpected RPC response, expected array of patches');\n      }\n      result[key] = patchValue(session, request.handle, `${request.method}-${key}`, result[key]);\n    });\n    // return a cloned response object to avoid patched object references:\n    return JSON.parse(JSON.stringify(response));\n  }\n  return response;\n}\n\n// export object reference for testing purposes:\ndeltaResponseInterceptor.sessions = sessions;\n","/**\n* Process error interceptor.\n* @private\n* @param {Session} session - The session the intercept is being executed on.\n* @param {Object} request - The JSON-RPC request.\n* @param {Object} response - The response.\n* @returns {Object} - Returns the defined error for an error, else the response.\n*/\nexport default function errorResponseInterceptor(session, request, response) {\n  if (typeof response.error !== 'undefined') {\n    const data = response.error;\n    const error = new Error(data.message);\n    error.code = data.code;\n    error.parameter = data.parameter;\n    return session.config.Promise.reject(error);\n  }\n  return response;\n}\n","const RETURN_KEY = 'qReturn';\n\n/**\n* Picks out the result \"out\" parameter based on the QIX method+schema, with\n* some specific handling for some methods that breaks the predictable protocol.\n* @private\n* @param {Session} session - The session the intercept is being executed on.\n* @param {Object} request - The JSON-RPC request.\n* @param {Object} response - The response.\n* @returns {Object} - Returns the result property on the response\n*/\nexport default function outParamResponseInterceptor(session, request, response) {\n  if (request.method === 'CreateSessionApp' || request.method === 'CreateSessionAppFromApp') {\n    // this method returns multiple out params that we need\n    // to normalize before processing the response further:\n    response[RETURN_KEY].qGenericId = response.qSessionAppId || response[RETURN_KEY].qGenericId;\n  } else if (request.method === 'GetInteract' || request.method === 'StoreTempSelectionState' || request.method === 'CreateTemporaryBookmark') {\n    // this method returns a qReturn value when it should only return\n    // meta.outKey: GetInteract\n    // qId: StoreTempSelectionState\n    delete response[RETURN_KEY];\n  }\n\n  if (hasOwnProperty.call(response, RETURN_KEY)) {\n    return response[RETURN_KEY];\n  }\n  if (request.outKey !== -1) {\n    return response[request.outKey];\n  }\n\n  return response;\n}\n","/**\n* Process result interceptor.\n* @private\n* @param {Session} session - The session the intercept is being executed on.\n* @param {Object} request - The JSON-RPC request.\n* @param {Object} response - The response.\n* @returns {Object} - Returns the result property on the response\n*/\nexport default function resultResponseInterceptor(session, request, response) {\n  return response.result;\n}\n","import deltaRequest from './interceptors/delta-request-interceptor';\nimport apiResponse from './interceptors/api-response-interceptor';\nimport deltaResponse from './interceptors/delta-response-interceptor';\nimport errorResponse from './interceptors/error-response-interceptor';\nimport outParamResponse from './interceptors/out-param-response-interceptor';\nimport resultResponse from './interceptors/result-response-interceptor';\n\n/**\n * Interceptor is a concept similar to mixins, but runs on a lower level. The interceptor concept\n * can augment either the requests (i.e. before sent to QIX Engine), or the responses (i.e. after\n * QIX Engine has sent a response). The interceptor promises run in parallel to the regular\n * promises used in enigma.js, which means that it can be really useful when you want to normalize\n * behaviors in your application.\n * @interface Interceptor\n */\n\n/**\n * @class InterceptorRequest\n * @implements {Interceptor}\n * @example <caption>Implement a request interceptor</caption>\n * const enigma = require('enigma.js');\n * const WebSocket = require('ws');\n * const schema = require('enigma.js/schemas/12.20.0.json');\n *\n * const session = enigma.create({\n *   schema,\n *   url: 'ws://localhost:9076/app/engineData',\n *   createSocket: (url) => new WebSocket(url),\n *   requestInterceptors: [{\n *     onFulfilled: function logRequest(sessionReference, request) {\n *       console.log('Request being sent', request);\n *       return request;\n *     }\n *   },\n * });\n */\n\n/**\n * @class InterceptorResponse\n * @implements {Interceptor}\n * @example <caption>Implement a request interceptor</caption>\n * const enigma = require('enigma.js');\n * const WebSocket = require('ws');\n * const schema = require('enigma.js/schemas/12.20.0.json');\n *\n * const session = enigma.create({\n *   schema,\n *   url: 'ws://localhost:9076/app/engineData',\n *   createSocket: (url) => new WebSocket(url),\n *   responseInterceptors: [{\n *     onRejected: function logError(sessionReference, request, error) {\n *       console.log('Error returned from QIX engine', error, 'Originating request:', request);\n *       // throw error so it's continued to be rejected:\n *       throw error;\n *     }\n *   },\n * });\n */\n\n/**\n * This method is invoked when a request is about to be sent to QIX Engine.\n * @function InterceptorRequest#onFulfilled\n * @param {Session} session The session executing the interceptor.\n * @param {Object} request The JSON-RPC request that will be sent.\n */\n\n/**\n * This method is invoked when a previous interceptor has rejected the\n * promise; use this to handle, for example, errors before they are sent into mixins.\n * @function InterceptorResponse#onRejected\n * @param {Session} session The session executing the interceptor. You may use .retry() to retry\n * sending it to QIX Engine.\n * @param {Object} request The JSON-RPC request resulting in this error.\n * @param {Object} error Whatever the previous interceptor is rejected with.\n */\n\n/**\n * This method is invoked when a promise has been successfully resolved;\n * use this to modify the result or reject the promise chain before it is sent\n * to mixins.\n * @function InterceptorResponse#onFulfilled\n * @param {Session} session The session executing the interceptor.\n * @param {Object} request The JSON-RPC request resulting in this response.\n * @param {Object} result Whatever the previous interceptor is resolved with.\n */\nclass Intercept {\n  /**\n  * Create a new Intercept instance.\n  * @private\n  * @param {Object} options The configuration options for this class.\n  * @param {Promise<Object>} options.Promise The promise constructor to use.\n  * @param {ApiCache} options.apis The ApiCache instance to use.\n  * @param {Array<Object>} [options.request] The additional request interceptors to use.\n  * @param {Array<Object>} [options.response] The additional response interceptors to use.\n  */\n  constructor(options) {\n    Object.assign(this, options);\n    this.request = [{ onFulfilled: deltaRequest }, ...this.request || []];\n    this.response = [\n      { onFulfilled: errorResponse },\n      { onFulfilled: deltaResponse },\n      { onFulfilled: resultResponse },\n      { onFulfilled: outParamResponse },\n      ...this.response || [],\n      { onFulfilled: apiResponse },\n    ];\n  }\n\n  /**\n  * Execute the request interceptor queue, each interceptor will get the result from\n  * the previous interceptor.\n  * @private\n  * @param {Session} session The session instance to execute against.\n  * @param {Promise<Object>} promise The promise to chain on to.\n  * @returns {Promise<Object>}\n  */\n  executeRequests(session, promise) {\n    return this.request.reduce((interception, interceptor) => {\n      const intercept = interceptor.onFulfilled\n        && interceptor.onFulfilled.bind(this, session);\n      return interception.then(intercept);\n    }, promise);\n  }\n\n  /**\n  * Execute the response interceptor queue, each interceptor will get the result from\n  * the previous interceptor.\n  * @private\n  * @param {Session} session The session instance to execute against.\n  * @param {Promise<Object>} promise The promise to chain on to.\n  * @param {Object} request The JSONRPC request object for the intercepted response.\n  * @returns {Promise<Object>}\n  */\n  executeResponses(session, promise, request) {\n    return this.response.reduce((interception, interceptor) => interception.then(\n      interceptor.onFulfilled && interceptor.onFulfilled.bind(this, session, request),\n      interceptor.onRejected && interceptor.onRejected.bind(this, session, request),\n    ), promise);\n  }\n}\n\nexport default Intercept;\n","import KeyValueCache from './key-value-cache';\n\n/**\n* API cache for instances of QIX types, e.g. GenericObject.\n* @private\n* @extends KeyValueCache\n*/\nclass ApiCache extends KeyValueCache {\n  /**\n  * Adds an API.\n  * @private\n  * @function ApiCache#add\n  * @param {Number} handle - The handle for the API.\n  * @param {*} api - The API.\n  * @returns {{api: *}} The entry.\n  */\n  add(handle, api) {\n    const entry = { api };\n    super.add(handle.toString(), entry);\n    api.on('closed', () => this.remove(handle));\n    return entry;\n  }\n\n  /**\n  * Gets an API.\n  * @private\n  * @function ApiCache#getApi\n  * @param {Number} handle - The handle for the API.\n  * @returns {*} The API for the handle.\n  */\n  getApi(handle) {\n    const entry = typeof handle !== 'undefined' ? this.get(handle.toString()) : undefined;\n    return entry && entry.api;\n  }\n\n  /**\n  * Gets a list of APIs.\n  * @private\n  * @function ApiCache#getApis\n  * @returns {Array} The list of entries including `handle` and `api` properties for each entry.\n  */\n  getApis() {\n    return super.getAll().map((entry) => ({\n      handle: entry.key,\n      api: entry.value.api,\n    }));\n  }\n\n  /**\n  * Gets a list of APIs with a given type.\n  * @private\n  * @function ApiCache#getApisByType\n  * @param {String} type - The type of APIs to get.\n  * @returns {Array} The list of entries including `handle` and `api` properties for each entry.\n  */\n  getApisByType(type) {\n    return this.getApis().filter((entry) => entry.api.type === type);\n  }\n}\n\nexport default ApiCache;\n","import Session from './session';\nimport Schema from './schema';\nimport RPC from './rpc';\nimport SuspendResume from './suspend-resume';\nimport Intercept from './intercept';\nimport ApiCache from './api-cache';\n\nimport createEnigmaError from './error';\nimport errorCodes from './error-codes';\n\n/**\n * The enigma.js configuration object.\n * @interface Configuration\n * @property {Object} schema Object containing the specification for the API to generate.\n * Corresponds to a specific version of the QIX Engine API.\n * @property {String} url String containing a proper websocket URL to QIX Engine.\n * @property {Function} [createSocket] A function to use when instantiating the WebSocket,\n * mandatory for Node.js.\n * @property {Object} [Promise] ES6-compatible Promise library.\n * @property {Boolean} [suspendOnClose=false] Set to true if the session should be suspended\n * instead of closed when the websocket is closed.\n * @property {Array<Mixin>} [mixins=[]] Mixins to extend/augment the QIX Engine API. Mixins\n * are applied in the array order.\n * @property {Array} [requestInterceptors=[]] Interceptors for augmenting requests before they\n * are sent to QIX Engine. Interceptors are applied in the array order.\n * @property {Array} [responseInterceptors=[]] Interceptors for augmenting responses before they\n * are passed into mixins and end-users. Interceptors are applied in the array order.\n * @property {Object} [protocol={}] An object containing additional JSON-RPC request parameters.\n * @property {Boolean} [protocol.delta=true] Set to false to disable the use of the\n * bandwidth-reducing delta protocol.\n * @example <caption>Example defining a configuration object</caption>\n * const enigma = require('enigma.js');\n * const WebSocket = require('ws');\n * const bluebird = require('bluebird');\n * const schema = require('enigma.js/schemas/12.20.0.json');\n *\n * const config = {\n *  schema,\n *  url: 'ws://localhost:4848/app/engineData',\n *  createSocket: url => new WebSocket(url),\n *  Promise: bluebird,\n *  suspendOnClose: true,\n *  mixins: [{ types: ['Global'], init: () => console.log('Mixin ran') }],\n *  protocol: { delta: false },\n * };\n *\n * enigma.create(config).open().then((global) => {\n *   // global === QIX global interface\n *   process.exit(0);\n * });\n */\n\n/**\n * The mixin concept allows you to add or override QIX Engine API functionality. A mixin is\n * basically a JavaScript object describing which types it modifies, and a list of functions\n * for extending and overriding the API for those types.\n *\n * QIX Engine types like, for example, GenericObject, Doc, GenericBookmark, are supported but\n * also custom GenericObject types such as barchart, story and myCustomType. An API will get\n * both their generic type as well as custom type mixins applied.\n *\n * Mixins that are bound to several different types can find the current API type in the\n * `genericType` or `type` members. `this.type` would, for instance, return `GenericObject` and\n * `this.genericType` would return `barchart`.\n *\n * See the Mixins examples on how to use it. Below is an outline of what the mixin API consists of.\n *\n * @interface Mixin\n * @property {String|Array<String>} types String or array of strings containing the API-types that\n * will be mixed in.\n * @property {Object} [extend] Object literal containing the methods that will be extended on the\n * specified API.\n * @property {Object} [override] Object literal containing the methods to override existing methods.\n * @property {Function} [init] Init function that, if defined, will run when an API is instantiated.\n * It runs with Promise and API object as parameters.\n */\n\n/**\n * The API for generated APIs depends on the QIX Engine schema you pass into your Configuration, and\n * on what QIX struct the API has.\n *\n * All API calls made using the generated APIs will return promises that are either resolved or\n * rejected depending on how the QIX Engine responds.\n *\n * @interface API\n * @property {String} id Contains the unique identifier for this API.\n * @property {String} type Contains the schema class name for this API.\n * @property {String} genericType Corresponds to the qInfo.qType property on the generic object's\n * properties object.\n * @property {Session} session Contains a reference to the session that this API belongs to.\n * @property {Number} handle Contains the handle QIX Engine assigned to the API. Used interally in\n * enigma.js for caches and JSON-RPC requests.\n * @example <caption>Example using `global` and `generic object` struct APIs</caption>\n * global.openDoc('my-document.qvf').then((doc) => {\n *   doc.createObject({ qInfo: { qType: 'my-object' } }).then(api => { });\n *   doc.getObject('object-id').then(api => { });\n *   doc.getBookmark('bookmark-id').then(api => { });\n * });\n */\n\n/**\n * Handles changes on the API. The changed event is triggered whenever enigma.js or QIX Engine has\n * identified potential changes on the underlying properties or hypercubes and you should re-fetch\n * your data.\n * @event API#changed\n * @type {Object}\n * @example <caption>Bind the `changed` event</caption>\n * api.on('changed', () => {\n *   api.getLayout().then(layout => { });\n * });\n */\n\n/**\n * Handles closed API. The closed event is triggered whenever QIX Engine considers an API closed.\n * It usually means that it no longer exists in the QIX Engine document or session.\n * @event API#closed\n * @type {Object}\n * @example <caption>Bind the `closed` event</caption>\n * api.on('closed', () => {\n *   console.log(api.id, 'was closed');\n * });\n */\n\n/**\n * Handles JSON-RPC requests/responses for this API. Generally used in debugging purposes.\n * `traffic:*` will handle all websocket messages, `traffic:sent` will handle outgoing messages\n * and `traffic:received` will handle incoming messages.\n * @event API#traffic\n * @type {Object}\n * @example <caption>Bind the traffic events</caption>\n * // bind both in- and outbound traffic to console.log:\n * api.on('traffic:*', console.log);\n * // bind outbound traffic to console.log:\n * api.on('traffic:sent', console.log);\n * // bind inbound traffic to console.log:\n * api.on('traffic:received', console.log);\n */\n\nclass Enigma {\n  /**\n   * Function used to get a session.\n   * @private\n   * @param {Configuration} config The configuration object for this session.\n   * @returns {Session} Returns a session instance.\n   */\n  static getSession(config) {\n    const {\n      createSocket,\n      Promise,\n      requestInterceptors,\n      responseInterceptors,\n      url,\n    } = config;\n    const apis = new ApiCache();\n    const intercept = new Intercept({\n      apis,\n      Promise,\n      request: requestInterceptors,\n      response: responseInterceptors,\n    });\n    const rpc = new RPC({ createSocket, Promise, url });\n    const suspendResume = new SuspendResume({ apis, Promise, rpc });\n    const session = new Session({\n      apis,\n      config,\n      intercept,\n      rpc,\n      suspendResume,\n    });\n    return session;\n  }\n\n  /**\n  * Function used to configure defaults.\n  * @private\n  * @param {Configuration} config The configuration object for how to connect\n  *                               and retrieve end QIX APIs.\n  */\n  static configureDefaults(config) {\n    if (!config) {\n      throw createEnigmaError(errorCodes.NO_CONFIG_SUPPLIED, 'You need to supply a configuration.');\n    }\n\n    // eslint-disable-next-line no-restricted-globals\n    if (!config.Promise && typeof Promise === 'undefined') {\n      throw createEnigmaError(errorCodes.PROMISE_REQUIRED, 'Your environment has no Promise implementation. You must provide a Promise implementation in the config.');\n    }\n\n    if (typeof config.createSocket !== 'function' && typeof WebSocket === 'function') {\n      // eslint-disable-next-line no-undef\n      config.createSocket = (url) => new WebSocket(url);\n    }\n\n    if (typeof config.suspendOnClose === 'undefined') {\n      config.suspendOnClose = false;\n    }\n\n    config.protocol = config.protocol || {};\n    config.protocol.delta = typeof config.protocol.delta !== 'undefined' ? config.protocol.delta : true;\n    // eslint-disable-next-line no-restricted-globals\n    config.Promise = config.Promise || Promise;\n    config.mixins = config.mixins || [];\n    config.definition = config.definition || new Schema(config);\n  }\n\n  /**\n  * Function used to create a QIX session.\n  * @entry\n  * @param {Configuration} config The configuration object for the QIX session.\n  * @returns {Session} Returns a new QIX session.\n  * @example <caption>Example minimal session creation</caption>\n  * const enigma = require('enigma.js');\n  * const schema = require('enigma.js/schemas/12.20.0.json');\n  * const WebSocket = require('ws');\n  * const config = {\n  *   schema,\n  *   url: 'ws://localhost:9076/app/engineData',\n  *   createSocket: url => new WebSocket(url),\n  * };\n  * const session = enigma.create(config);\n  */\n  static create(config) {\n    Enigma.configureDefaults(config);\n    config.mixins.forEach((mixin) => {\n      config.definition.registerMixin(mixin);\n    });\n    return Enigma.getSession(config);\n  }\n}\n\nexport default Enigma;\n"],"names":["util","EventEmitter","init","call","this","isObject","arg","isNumber","isUndefined","isFunction","nodeEventEmitter","prototype","_events","undefined","_maxListeners","defaultMaxListeners","setMaxListeners","n","isNaN","TypeError","emit","type","er","handler","len","args","i","listeners","error","arguments","Error","length","Array","apply","slice","addListener","listener","m","newListener","push","warned","console","trace","on","once","fired","g","removeListener","list","position","splice","removeAllListeners","key","isArray","listenerCount","emitter","Events","obj","Object","keys","forEach","EnigmaError","_Error","_inherits","_super","name","code","original","_this","_classCallCheck","enigmaError","_wrapNativeSuper","createEnigmaError","errorCodes","cacheId","Session","options","session","assign","Promise","config","definition","id","rpc","onRpcError","bind","onRpcClosed","onRpcMessage","onRpcNotification","onRpcTraffic","onSessionClosed","value","err","suspendResume","isSuspended","evt","suspendOnClose","reason","suspend","then","initiator","response","_this2","change","handle","emitHandleChanged","close","emitHandleClosed","method","params","concat","dir","data","api","apis","getApi","getApis","entry","clear","genericType","generate","factory","add","_this3","globalPromise","open","getObjectApi","global","request","_this4","reject","closeEvent","createRequestId","promise","intercept","executeRequests","resolve","augmentedRequest","_objectSpread","protocol","outKey","send","retry","executeResponses","addToPromiseChain","_this5","onlyIfAttached","_this6","resume","_this7","_len","_key","chain","KeyValueCache","entries","map","filter","hasOwnProperty","toCamelCase","symbol","substring","toLowerCase","namedParamFacade","base","defaults","_typeof","valid","every","Schema","schema","mixins","types","_ref","extend","override","cached","typeKey","entryList","get","structs","generateApi","create","generateDefaultApi","mixinType","mixinNamedParamFacade","customKey","instance","defineProperties","enumerable","writable","mixinList","mixin","out","Out","Name","fnName","_len2","_key2","_ref2","_ref2$extend","_ref2$override","baseFn","_len3","_key3","In","reduce","result","item","DefaultValue","_len4","_key4","RPCResolver","RPC","resolvers","requestId","openedPromise","force","socket","createSocket","url","onopen","onOpen","onclose","onClose","onerror","onError","onmessage","onMessage","registerResolver","closedPromise","opened","resolveWith","event","closed","rejectAllOutstandingResolvers","rejectWith","JSON","parse","resolver","resolvedId","unregisterResolver","rejectedId","readyState","OPEN","jsonrpc","stringify","SuspendResume","openDocParams","reopen","sessionState","changed","getApisByType","pop","doc","qReturn","qHandle","tasks","buildGetMethodName","all","restoreRpcConnection","restoreGlobal","restoreDoc","restoreDocObjects","timeout","timer","notificationResolve","notificationReceived","notificationPromise","onNotification","clearTimeout","qSessionState","setTimeout","state","replace","deltaRequestInterceptor","delta","apiResponseInterceptor","qType","qGenericId","qGenericType","hasOwn","toStr","toString","defineProperty","gOPD","getOwnPropertyDescriptor","arr","isPlainObject","hasOwnConstructor","hasIsPrototypeOf","constructor","setProperty","target","configurable","newValue","getProperty","src","copy","copyIsArray","clone","deep","JSONPatch","v","isUndef","isSpecialProperty","getParent","str","numPart","parts","split","part","newPart","compare","a","b","isIdentical","l","newData","basePath","patches","val","generateValue","oldVal","tmpPath","op","path","newA","oldA","tmpIdx","findIndex","idx","qInfo","qId","ii","ll","from","patchArray","patch","parent","_target","chunk","_toConsumableArray","oldParent","createPatch","updateObject","sessions","getHandleCache","cache","bindSession","deltaResponseInterceptor","set","patchValue","errorResponseInterceptor","message","parameter","RETURN_KEY","outParamResponseInterceptor","qSessionAppId","resultResponseInterceptor","Intercept","onFulfilled","deltaRequest","errorResponse","deltaResponse","resultResponse","outParamResponse","apiResponse","interception","interceptor","onRejected","ApiCache","_KeyValueCache","_createSuper","_get","_getPrototypeOf","remove","Enigma","requestInterceptors","responseInterceptors","WebSocket","configureDefaults","registerMixin","getSession"],"mappings":"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"}